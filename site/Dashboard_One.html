<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Dashboard - One</title>
	<script src="https://www.chartjs.org/dist/2.9.3/Chart.min.js"></script>
	<script src="https://www.chartjs.org/samples/latest/utils.js"></script>
	<style>
		canvas {
			-moz-user-select: none;
			-webkit-user-select: none;
			-ms-user-select: none;
		}
	</style>
	<link rel="stylesheet" href="../site/assets/css/header.css">
	<link rel="stylesheet" href="../site/assets/css/footer.css">
	<link rel="stylesheet" href="../site/assets/css/api.css">
	<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@300&display=swap" rel="stylesheet">
	<link rel="shortcut icon" href="./assets/img/favicon.ico" type="image/x-icon">
</head>

<body class="body">
	<img class="imgFundo" src="../site/assets/img/background.png">
	<header class="header">
		<div class="header-box">
			<a href="../site/home.html">
			<img class="header-box-img" src="../site/assets/img/logoOne.png" alt="logo">
		</a>
		</div>
		<ul class="header-ul">
			<a href="../site/sobre.html">
				<li class="header-ul-li">sobre</li>
			</a>
			<a href="../site/contato.html">
				<li class="header-ul-li">contato</li>
			</a>
			<a href="../site/login.html">
				<li class="header-ul-li">login</li>
			</a>
		</ul>
	</header>
	<div style="display: flex;flex-direction: column;align-items: center;">
		<div style="width: 60%;margin-top: 100px;">
			<canvas id="grafico_temp"></canvas>
		</div>
		<div style="width: 60%;margin-top: 50px;">
			<canvas id="grafico_umid"></canvas>
		</div>
	</div>
	<footer class="footer-api">
		<p class="footer-text"> One - solutions</p>
		<div class="footer-box">
			<img class="footer-box-img" src="../site/assets/img/github-logo.svg" alt="" class="footer-box">
			<img class="footer-box-img" src="../site/assets/img/facebook-circular-logo.svg" alt="" class="footer-box">
		</div>
	</footer>

</body>

</html>

<script>

	var config_temp = {
		type: 'line',
		data: {
			labels: [],
			datasets: [{
				label: 'Temperatura',
				borderColor: '#f21111',
				borderWidth: 5,
				backgroundColor: '#000000a4',
				gridLines: {
					color: '#ff0000'
				},
				data: [],
				fill: true,
			}]
		},
		options: {
			responsive: true,
			title: {
				display: true,
				text: 'Gráfico de histórico de temperatura',
				fontColor: 'White'
			},
			tooltips: {
				mode: 'index',
				intersect: false,
			},
			hover: {
				mode: 'nearest',
				intersect: true
			},
			scales: {
				xAxes: [{
					Color: 'rgba(255, 255, 255)',
					display: true,
					gridLines: {
						color: '#fff'
					},
					scaleLabel: {
						display: true,
						labelString: 'Horário da Leitura',
						fontColor: 'White'
					}
				}],
				yAxes: [{
					display: true,
					gridLines: {
						color: '#fff'
					},
					scaleLabel: {
						display: true,
						labelString: 'ºC',
						fontColor: 'White'
					}
				}]
			}
		}
	};

	var config_umid = {
		type: 'line',
		data: {
			labels: [],
			datasets: [{
				label: 'Umidade',
				borderColor: '#fff',
				borderWidth: 5,
				backgroundColor: '#000000a4',
				data: [],
				fill: true,
			}]
		},
		options: {
			responsive: true,
			title: {
				display: true,
				text: 'Gráfico de histórico de umidade',
				fontColor: 'White'
			},
			tooltips: {
				mode: 'index',
				intersect: false,
			},
			hover: {
				mode: 'nearest',
				intersect: true
			},
			scales: {
				xAxes: [{
					display: true,
					gridLines: {
						color: '#fff'
					},
					scaleLabel: {
						display: true,
						labelString: 'Horário da Leitura',
						fontColor: 'White'
					}

				}],
				yAxes: [{
					display: true,
					gridLines: {
						color: '#fff'
					},
					scaleLabel: {
						display: true,
						labelString: '%',
						fontColor: 'White'
					}
				}]
			}
		}
	};
	// esse "sortearTemperatura()" será desnecessário quando usarmos o backend futuramente
	function sortear_Temp() {
		var limiteMin = 18;
		var limiteMax = 27;
		var minimoAbsoluto = Math.abs(limiteMin);
		return (Math.random() * (minimoAbsoluto && limiteMax)).toFixed(1);
	}
	function sortear_umid() {
		var limiteMin = 40;
		var limiteMax = 55;
		var minimoAbsoluto = Math.abs(limiteMin);
		return (Math.random() * (minimoAbsoluto && limiteMax)).toFixed(1);
	}

	function recuperarDadosIniciais() {

		// esse "registros" será recuperado do backend futuramente
		var registros_temp = [
			{
				momento: '',
				leitura: sortear_Temp()
			},
			{
				momento: '',
				leitura: sortear_Temp()
			},
			{
				momento: '',
				leitura: sortear_Temp()
			},
			{
				momento: '',
				leitura: sortear_Temp()
			},
			{
				momento: '',
				leitura: sortear_Temp()
			},
			{
				momento: '',
				leitura: sortear_Temp()
			},
			{
				momento: '',
				leitura: sortear_Temp()
			},
			{
				momento: '',
				leitura: sortear_Temp()
			}
		];
		var registros_umid = [
			{
				momento: '',
				leitura: sortear_umid()
			},
			{
				momento: '',
				leitura: sortear_umid()
			},
			{
				momento: '',
				leitura: sortear_umid()
			},
			{
				momento: '',
				leitura: sortear_umid()
			},
			{
				momento: '',
				leitura: sortear_umid()
			},
			{
				momento: '',
				leitura: sortear_umid()
			},
			{
				momento: '',
				leitura: sortear_umid()
			},
			{
				momento: '',
				leitura: sortear_umid()
			}
		];

		var contador = 0;
		var contador2 = 0;
		// registros.length é a quantidade de itens em "registros"
		while (contador < registros_temp.length) {

			config_temp.data.labels.push(registros_temp[contador].momento);  // incluir um novo momento
			config_temp.data.datasets[0].data.push(registros_temp[contador].leitura);  // incluir uma nova leitura

			contador++;
		}
		while (contador2 < registros_umid.length) {

			config_umid.data.labels.push(registros_umid[contador2].momento);
			config_umid.data.datasets[0].data.push(registros_umid[contador2].leitura);  // incluir uma nova leitura

			contador2++;
		}


	}

	function receberNovasLeituras() {
		setTimeout(() => {

			// esses "agora" etc até "momentos" serão desnecessários quando usarmos o backend futuramente
			var agora = new Date();
			var hora = agora.getHours();
			var minuto = agora.getMinutes();
			var segundo = agora.getSeconds();
			var momento = `${hora > 9 ? '' : '0'}${hora}:${minuto > 9 ? '' : '0'}${minuto}:${segundo > 9 ? '' : '0'}${segundo}`;

			// esse "novoRegistro" será recuperado do backend futuramente
			var novoRegistro = {
				momento: momento,
				leitura: sortear_Temp()
			};
			var novoRegistro2 = {
				momento: momento,
				leitura: sortear_umid()
			}

			// tirando e colocando valores no gráfico
			config_temp.data.labels.shift(); // apagar o primeiro
			config_temp.data.labels.push(novoRegistro.momento); // incluir um novo momento
			config_temp.data.datasets[0].data.shift();  // apagar o primeiro
			config_temp.data.datasets[0].data.push(novoRegistro.leitura); // incluir uma nova leitura

			config_umid.data.labels.shift(); // apagar o primeiro
			config_umid.data.labels.push(novoRegistro2.momento); // incluir um novo momento
			config_umid.data.datasets[0].data.shift();  // apagar o primeiro
			config_umid.data.datasets[0].data.push(novoRegistro2.leitura); // incluir uma nova 

			// Atualiza o gráfico
			window.graficoLinha.update();
			window.graficoLinha_2.update();

			// agendar a chamada da mesma função para daqui a 7 segundos
			receberNovasLeituras();

		}, 3000); // 3000 ms -> 3 segundos
	}

	function plotarGrafico() {
		// chamar os 7 últimos registros de leitura
		recuperarDadosIniciais();

		// criação do gráfico na página
		var ctx = document.getElementById('grafico_temp').getContext('2d');
		window.graficoLinha = new Chart(ctx, config_temp);

		var ctx2 = grafico_umid.getContext('2d');
		window.graficoLinha_2 = new Chart(ctx2, config_umid)

		Chart.defaults.global.defaultFontColor = '#fff'

		// função que agenda a recuperação da última leitura para daqui a 7 segundos
		receberNovasLeituras();
	}

	// indicando que a função "plotarGrafico" será invocada assim que a página carregar
	window.onload = plotarGrafico;

</script>